
class PnLPosTracker(ABC):
    def __init__(self, calendar='HKG', country_issued_code='HK', save=False, save_dir='', loadsymap=True):
        self.fut_contract_size = pd.Series({'HSI': 50, 'HCEI': 50})
        self.trd_stats_header = ['n_buy', 'n_sell', 'stk_delta_buy', 'stk_delta_sell', 'stk_delta_nettrd', 'max_buy', 'max_sell']
        self.pos_stats_header = ['nlong', 'nshort', 'stk_delta_long', 'stk_delta_short', 'max_stk_long', 'max_stk_short', 'stk_delta_net', 'hdg_delta_net', 'cash']
        self.pnl_stats_header = ['pos_pnl', 'pos_pnl_hdg', 'trd_pnl', 'trd_pnl_hdg', 'daily_pnl', 'dividend', 'split']
        self.cc = calendar
        self.save = save
        self.save_dir = save_dir
        if loadsymap:
            self.get_symap(country_issued_code)

    def get_symap(self, country_issued_code='HK'): # county_issued_code could be HK, TW, CH
        # first, we load an in-house databased that maps between all kinds of symbols
        # such as bloomberg code, ticker, ric, cusip, isin, sedol and etc.
        # then we load factset database that maps between sedol and fsym_id
        sedols = usm.getsyms(['ric_code', 'bb_composite_code', 'sedol_code'], filter="country_issued_code='{}'".format(country_issued_code))
        sedols = sedols[~sedols.sedol_code.isnull()].copy()
        sedols.index = sedols.ric_code.values
        tdf = ufs.sedol2fsym(sedols.sedol_code.values)
        tdf.index = tdf.sedol
        sedols['fsym'] = tdf.fsym.reindex(sedols.sedol_code.values).values
        sedols['rics'] = sedols.index.values
        self.symap = sedols
        self.ric2fsym = sedols.fsym

    @abstractmethod
    def get_trades(self, ymd):
        # this function must return a data frame with ric, side, size, price, sgn, sgnval, absval and timestamp
        pass

    @abstractmethod
    def get_position(self, ymd):
        # return a data frame with ric, shares and close prices, index is ric
        pass

    def gen_trd_stats(self, trddf):
        if trddf.shape[0] < 1:
            return [0] * len(self.trd_stats_header)
        ishedge = self.ishedge(trddf.ric.values)
        trddf = trddf[~ishedge]
        bf = trddf.side.str[0] == 'B'
        n_buy = (bf).sum()
        n_sell = (~bf).sum()
        delta_buy = trddf.absval[bf].sum()
        delta_sell = trddf.absval[~bf].sum()
        delta_net = trddf.sgnval.sum()
        max_buy = max(trddf.absval[bf].values, default=0)
        max_sell = max(trddf.absval[~bf].values, default=0)
        return [n_buy, n_sell, delta_buy, delta_sell, delta_net, max_buy, max_sell]

    def gen_pos_stats(self, pos):
        if pos.shape[0] < 1:
            return [0] * len(self.pos_stats_header)
        cash = pos['shares'].get('cash', 0)
        subpos = pos[pos.index != 'cash']
        ishedge = self.ishedge(subpos.index.values)
        delta = subpos.shares.values * subpos.clspr.values
        nethedge = delta[ishedge].sum()
        absdelta = np.abs(delta)
        lf = subpos.shares > 0
        f1 = (lf) & (~ishedge)
        f2 = (~lf) & (~ishedge)
        n_long = f1.sum()
        n_short = f2.sum()
        delta_long = absdelta[f1].sum()
        delta_short = absdelta[f2].sum()
        delta_net = delta[~ishedge].sum()
        max_long = max(absdelta[f1], default=0)
        max_short = max(absdelta[f2], default=0)
        return[n_long, n_short, delta_long, delta_short, max_long, max_short, delta_net, nethedge, cash]

    def gen_pnl_stats(self, prev_pos, sod_pos, trddf):
        if sod_pos.shape[0] > 0:
            hf1 = self.ishedge(sod_pos.index.values)
            hf0 = self.ishedge(prev_pos.index.values)
            pos_pnl = np.dot(sod_pos.shares.values, sod_pos.clspr.values) - np.dot(prev_pos.shares.values, prev_pos.clspr.values)
            pos_pnl_hdg = np.dot(sod_pos.shares.values[hf1], sod_pos.clspr.values[hf1]) - np.dot(prev_pos.shares.values[hf0], prev_pos.clspr.values[hf0])
        else:
            pos_pnl = 0.0
            pos_pnl_hdg = 0.0
        posdiff = sod_pos.shares - prev_pos.shares
        dividend = posdiff.get('cash', default=0.0)
        if 'cash' in posdiff.index:
            posdiff.drop(index=['cash'], inplace=True)
        split = (posdiff != 0).sum() > 0
        trd_pnl = (trddf.sgnsize * (trddf.clspr - trddf.price)).sum()
        hf = self.ishedge(trddf.ric.values)
        trd_pnl_hdg = (trddf.sgnsize * (trddf.clspr - trddf.price))[hf].sum()
        daily_pnl = pos_pnl + trd_pnl
        return [pos_pnl, pos_pnl_hdg, trd_pnl, trd_pnl_hdg, daily_pnl, dividend, split]

    def adjust_cac(self, pos, ymd):
        rics = np.array(list(set(pos.index.values) - set(['cash'])))
        if len(rics) < 1:
            return
        f_hedge = self.ishedge(rics)
        rics = rics[~f_hedge]
        if len(rics) < 1:
            return
        fsyms = self.ric2fsym.reindex(rics).values
        fsym2ric = pd.Series(rics, index=fsyms)
        splits = ufs.get_splits(fsyms, ymd, ymd)
        divs = ufs.get_divs(fsyms, ymd, ymd)
        total_div = 0.0
        if splits.shape[0] > 0:
            splits.index = fsym2ric.reindex(splits.fsym_id.values).values
            for i in range(splits.shape[0]):
                ric = splits.index[i]
                split_factor = splits['p_split_factor'].iloc[i]
                pos.loc[ric, 'shares'] = pos.loc[ric, 'shares'] / split_factor
            print(splits)
        if divs.shape[0] > 0:
            divs.index = fsym2ric.reindex(divs.fsym_id.values).values
            for i in range(divs.shape[0]):
                ric = divs.index[i]
                is_spinoff = divs['p_divs_s_spinoff'].iloc[i]
                div_amount = divs['p_divs_pd'].iloc[i]
                if is_spinoff:
                    total_div = total_div + pos.loc[ric, 'shares'] * pos.loc[ric, 'clspr']
                    print('Spinoff, {} deleted {}'.format(ric, pos.loc[ric]))
                    pos.drop(index=ric, inplace=True)
                else:
                    total_div = total_div + pos.loc[ric, 'shares'] * div_amount
            print(divs)
        pos.loc['cash', 'shares'] += total_div
        return

    def get_clspr(self, rics, ymd):
        rics = np.array(list(set(rics) - set(['cash'])))
        if len(rics) < 1:
            return pd.Series([1.0],index=['cash'])
        f_hedge = self.ishedge(rics)
        rics_stk = rics[~f_hedge]
        rics_hdg = rics[f_hedge]

        if len(rics_stk) > 0:
            fsyms = self.ric2fsym.reindex(rics_stk).values
            fsym2ric = pd.Series(rics_stk, index=fsyms)
            prices = ufs.get_prices(fsyms, ymd, ymd)
            prices.index = fsym2ric.reindex(prices.fsym_id.values).values
        else:
            prices = pd.DataFrame(columns=['p_price'])

        if len(rics_hdg) > 0:
            bbg_hdg = [self.ric2bbg_futures(x) for x in rics_hdg]
            bbg2ric = pd.Series(rics_hdg, bbg_hdg)
            bapi = ubb.BloomObject()
            tdf = bapi.bdh(bbg_hdg, ['PX_LAST'], pd.to_datetime(ymd), pd.to_datetime(ymd), optional_param_dict=ubb.no_adjust_override)
            tdf.index = bbg2ric.redinex(tdf.Id.values)
        else:
            tdf = pd.DataFrame(columns=['PX_LAST'])

        ss = pd.concat([prices.p_price, tdf.PX_LAST], axis=0)
        ss['cash'] = 1.0
        return ss

    def save_df(self, df, ymd, prefix):
        data_dir = '{}/{}'.format(self.save_dir, ymd)
        if not os.path.exists(data_dir):
            os.makedirs(data_dir)
        fn = '{}/{}.csv'.format(data_dir, prefix)
        df.to_csv(fn)

    def gen_eod_trd_pos(self, ymd, clsprtype='local'): # this is end of trading day position, no adjust for cac
        sod_pos = self.get_sod_position(ymd)
        if sod_pos.shape[0] > 1:
            clspr = self.get_clspr(sod_pos.index.values, ymd, clsprtype).reindex(sod_pos.index.values).values
            ff = pd.isnull(clspr)
            if ff.sum() > 0:
                print("!!!  previous positon no close price !!!")
                print(sod_pos[ff])
            sod_pos.loc['cash', 'shares'] += (sod_pos.shares * sod_pos.clspr)[ff].sum()
            sod_pos['clspr'] = clspr
            sod_pos.drop(index=sod_pos.index[ff], inplace=True)
        trddf = self.get_raw_trades(ymd)
        if trddf.shape[0] > 0:
            trddf['clspr'] = self.get_clspr(trddf.ric.values, ymd, clsprtype).reindex(trddf.ric.values).values
            if trddf.clspr.isnull().sum() > 0:
                print("!!! trade no close price !!!")
                print(trddf[trddf.clspr.isnull()])
            change_shares = trddf.groupby('ric')['sgnsize'].sum()
            change_shares['cash'] = -trddf.sgnval.sum()
        else:
            trddf['clspr'] = []
            change_shares = pd.Series()
        pos = pd.DataFrame(pd.concat([sod_pos.shares, change_shares], axis=1, sort=True).fillna(0).sum(axis=1), columns=['shares'])
        pos = pos[pos.shares.abs() > 0].copy()
        if pos.shape[0] > 0:
            pos['clspr'] = self.get_clspr(pos.index.values, ymd, clsprtype).reindex(pos.index.values).values
        else:
            pos['clspr'] = []
        self.save_df(sod_pos, ymd, 'sod_position')
        self.save_df(pos, ymd, 'position')
        self.save_df(trddf, ymd, 'trades')

    def gen_sod_position(self, ymd, currency='local'):
        prev_ymd = udt.getTradingDays(ymd, cc=self.cc)
        prev_pos = self.get_position(prev_ymd)
        self.adjust_cac(prev_pos, ymd, currency)
        self.save_df(prev_pos, ymd, 'sod_position')

    def gen_all_stats(self, st, en):
        trds = [dt.strftime('%Y%m%d') for dt in udt.getTradingDays(udt.getPrevTrd(st), en, cc=self.cc)]
        rows = []
        for i in range(1, len(trds)):
            prev_ymd = trds[i-1]
            ymd = trds[i]
            print(ymd)
            prev_pos = self.get_position(prev_ymd)
            sod_pos = self.get_sod_position(ymd)
            trddf = self.get_trades(ymd)
            pos = self.get_position(ymd)
            t_stat = self.gen_trd_stats(trddf)
            p_stat = self.gen_pos_stats(pos)
            pnl_stat = self.gen_pnl_stats(prev_pos, sod_pos, trddf)
            rows.append(t_stat + p_stat + pnl_stat)
            tdf = pd.concat([prev_pos.shares, * prev_pos.clspr, sod_pos.shares * sod_pos.clspr], axis=1)
            tdf.fillna(0.0, inplace=True)
            tdf.columns = ['prev_pos', 'sod_pos']
            tdf['pnl'] = tdf.sod_pos - tdf.prev_pos
            dividends = self.get_dividend(ymd)
            tdf['div'] = dividends.total_div.reindex(tdf.index.values, fill_value=0.0).values
            self.pospnl[ymd] = tdf
            self.trdpnl = trddf
        stats = pd.DataFrame(rows, columns=self.trd_stats_header + self.pos_stats_header + self.pnl_stats_header, index=trddf[1:])
        stats['cum_pnl'] = stats.daily_pnl.cumsum()
        return stats

    def change_currency(self, stats, fxrate=7.8):
        if type(self) == QMM_PnLPosTracker:
            cols = ['stk_delta_buy_RA', 'stk_delta_sell_RA']
        else:
            cols = ['stk_delta_buy', 'stk_delta_sell']
        for coln in cols:
            stats[coln] = stats[coln] / fxrate

    def get_trades(self, ymd):
        fn = '{}/{}/trades.csv'.format(self.save_dir, ymd)
        if os.path.exists(fn):
            pos = pd.read_csv(fn, index_col=0, converters={'ts': pd.Timestamp})
        else:
            pos = pd.DataFrame(columns=['ric', 'side', 'size', 'price', 'sgn', 'sgnsize', 'sgnval', 'absval'])
        return pos

    def get_position(self, ymd):
        fn = '{}/{}/position.csv'.format(self.save_dir, ymd)
        if os.path.exists(fn):
            pos = pd.read_csv(fn, index_col=0)
        else:
            pos = pd.DataFrame(columns=['shares', 'clspr'])
        return pos

    def get_sod_position(self, ymd):
        fn = '{}/{}/position.csv'.format(self.save_dir, ymd)
        if os.path.exists(fn):
            pos = pd.read_csv(fn, index_col=0)
        else:
            pos = pd.DataFrame(columns=['shares', 'clspr'])
        return pos

    def get_dividends(self, ymd):
        fn = '{}/{}/dividends.csv'.format(self.save_dir, ymd)
        if os.path.exists(fn):
            divs = pd.read_csv(fn, index_col=0)
        else:
            divs = pd.DataFrame(columns=['fsym_id', 'divs_exdate', 'p_divs_pd', 'currency', 'p_divs_s_spinoff', 'p_divs_s_pd', 'shares', 'total_div'])
        return divs

class QMM_PnLPosTracker(PnLPosTracker):
    def get_raw_trades(self, ymd):
        df = uwb.get_strategy_trades(ymd, 'ATSQMM')
        df['ymd'] = pd.to_datetime(df['ts']).dt.strftime('%Y%m%d')
        df = pd.concat([df, manualrolltrds, ioitrades], axis=0, sort=True)
        df['ishedge'] = self.ishedge(df.ric.values)
        return df

    def isfuture(self, rics):
        return np.array([x[0:-2] in ('HSI', 'HCEI') for x in rics])

    def ishedge(self, rics):
        return np.array([x[0:-2] in ('HSI', 'HCEI') for x in rics])

    def get_future_root(self, rics):
        return np.array([x[0:-2] for x in rics])

    def ric2bbg_futures(self, ric):
        d = {'HSI': 'HI', 'HCEI': 'HC'}
        return d[ric[0:-2]] + ric[-2:] + 'Index'

    def gen_trd_stats(self, trddf): # overide for QMM because i want separate RA annd RM
        if trddf.shape[0] < 1:
            return [0] * len(self.trd_stats_header)
        ishedge = self.ishedge(trddf.ric.values)
        trddf = trddf[~ishedge]
        is_omm = trddf.ric.isin(self.omm)
        is_warrant = trddf.crosstradingaccount.isin(['DTG'])
        is_deriv = trddf.crosstradingaccount.isin(['HKI3'])
        bf = trddf.side.str[0] == 'B'
        raf = trddf.algo == 'RA'
        rmf = trddf.algo == 'RM'
        n_buy = (bf).sum()
        n_sell = (~bf).sum()
        delta_buy_ra = trddf.absval[bf&raf].sum()
        delta_sell_ra = trddf.absval[(~bf)&raf].sum()
        delta_buy_rm = trddf.absval[bf & rmf].sum()
        delta_sell_rm = trddf.absval[(~bf) & rmf].sum()
        delta_net = trddf.sgnval.sum()
        max_buy = max(trddf.absval[bf].values, default=0)
        max_sell = max(trddf.absval[~bf].values, default=0)
        warrant_notional = trddf.absval[raf&is_warrant].sum()
        deriv_notional = trddf.absval[raf&is_deriv&(~is_omm)].sum()
        warrant_notional_rm = trddf.absval[rmf & is_warrant].sum()
        deriv_notional_rm = trddf.absval[rmf & is_deriv & (~is_omm)].sum()
        self.trd_stats_header = ['n_buy', 'n_sell', 'stk_delta_buy_RA', 'stk_delta_sell_RA', 'stk_delta_buy_RM', 'stk_delta_sell_RM', 'stk_delta_nettrd', 'max_buy', 'max_sell', 'warrant_notional_ra', 'deriv_notional_ra', 'warrant_notional_rm', 'deriv_notional_rm']
        return [n_buy, n_sell, delta_buy_ra, delta_sell_ra, delta_buy_rm, delta_sell_rm, delta_net, max_buy, max_sell, warrant_notional, deriv_notional, warrant_notional_rm, deriv_notional_rm]

    def get_trades(self, ymd):
        fn = '{}/{}/trades.csv'.format(self.save_dir, ymd)
        if os.path.exists(fn):
            trddf = pd.read_csv(fn, index_col=0)
            if 'algo' not in trddf.columns:
                trddf['algo'] = ''
                trddf.loc[(trddf.sgn == 1) & (~self.ishedge(trddf.ric.values)), 'algo'] = 'RA'
                trddf.loc[(trddf.sgn == -1) & (~self.ishedge(trddf.ric.values)), 'algo'] = 'RM'
            else:
                trddf = pd.DataFrame(columns=['ric', 'side', 'size', 'price', 'sgn', 'sgnsize', 'sgnval', 'absval', 'algo'])
            return trddf
