

import pandas as pd
import numpy as np
import feather
import os
import itertools
import Utils.MyDateTime as udt
import Utils.FactsetData as ufs
import Utils.BloombergAPI as ubb
import Utils.SymbolMapping as usm

params = {
    'PerSymMaxDelta': 7.7501e6
}
periods = [
    ['20200519', '20201120']
]

bapi = ubb.BloomObject()

def adjust_cac(pos, ymd):
    bbgs = pos.keys()
    tmp_df = bapi.bdp([x+' Equity' for x in bbgs], ['ID_SEDOL1'])
    tmp_df.index = tmp_df.Id.apply(lambda x: x[:-7])
    sedols = tmp_df.ID_SEDOL1.reindex(bbgs).values
    fsyms = ufs.sedol2fsym(sedols)
    fsyms.index = fsyms.sedol.values
    tmp_df['fsym'] = fsyms.fsym.reindex(tmp_df.ID_SEDOL1.values).values
    tmp_df['bbg'] = tmp_df.index.values
    tmp_df.index = tmp_df.fsym.values
    splits = ufs.get_splits(fsyms.fsym.values, ymd, ymd)
    divs = ufs.get_divs(fsyms.fsym.vlaues, ymd, ymd)
    total_div = 0.0
    if splits.shape[0] > 0:
        splits.index = tmp_df.bbg.reindex(splits.fsym_id.values).values
        for i in range(splits.shape[0]):
            bbg = tmp_df.loc[splits['fsym_id'].iloc[i], 'bbg']
            split_factor = splits['p_split_factor'].iloc[i]
            pos[bbg]['totalqty'] = pos[bbg]['totalqty'] / split_factor
            for i in range(len(pos[bbg]['qty'])):
                pos[bbg]['qty'][i][0] = pos[bbg]['qty'][i][0] / split_factor
        print(splits)
    if divs.shape[0] > 0:
        divs.index = tmp_df.bbg.reindex(divs.fsym_id.values).values
        for i in range(divs.shape[0]):
            bbg = divs.index.values[i]
            is_spinoff = divs['p_divs_s_pd'].iloc[i]
            div_amount = divs['p_divs_pd'].iloc[i]
            if is_spinoff:
                total_div = total_div + pos[bbg]['delta']
                print('Spinoff, {} deleted {}'.format(bbg, pos[bbg]['delta']))
                del pos[bbg]
            else:
                total_div = total_div + pos[bbg]['sgn'] * pos[bbg]['totalqty'] * div_amount
        print(divs)
    return total_div

def adjust_cac_hdg(hdg_pos, ymd):
    sedol = '6188557'
    fsym = 'MWP245-R'
    splits = ufs.get_splits([fsym], ymd, ymd)
    divs = ufs.get_divs([fsym], ymd, ymd)
    total_div = 0.0
    if splits.shape[0] > 0:
        for i in range(splits.shape[0]):
            split_factor = splits['p_split_factor'].iloc[i]
            hdg_pos['sgnqty'] = hdg_pos['sgnqty'] / split_factor
        print(splits)
    if divs.shape[0] > 0:
        for i in range(divs.shape[0]):
            is_spinoff = divs['p_divs_s_pd'].iloc[i]
            div_amount = divs['p_divs_pd'].iloc[i]
            if is_spinoff:
                total_div = total_div + hdg_pos['delta']
            else:
                total_div = total_div + hdg_pos['sgnqty'] * div_amount
        print(divs)
    return total_div

# trd [-rec['sgn'], rec['qdone_t'], rec['stamp']
def update_pos_internal(pos, sym, trd):
    if sym not in pos:
        pos[sym] = {}
        if trd[1] * trd[3] > params['PerSymMaxDelta']:
            trd[1] = int(params['PerSymMaxDelta'] / trd[3])
        pos[sym]['totalqty'] = trd[1]
        pos[sym]['sgn'] = trd[0]
        pos[sym]['qty'] = [[trd[1], trd[2]]]
    sympos = pos[sym]
    if sympos['sgn'] == trd[0]:
        if sympos['totalqty'] + trd[1] > int(params['PerSymMaxDelta'] / trd[3]):
            trd[1] = max(0, int(params['PerSymMaxDelta'] / trd[3]) - sympos['totalqty'])
            sympos['totalqty'] = sympos['totalqty'] + trd[1]
            sympos['qty'].append([trd[1], trd[2]])
    else:
        if trd[1] == sympos['totalqty']:
            del pos[sym]
        elif trd[1] > sympos['totalqty']:
            sympos['sgn'] = trd[0]
            if trd[1] - sympos['totalqty'] > int(params['PerSymMaxDelta'] / trd[3]):
                trd[1] = int(params['PerSymMaxDelta'] / trd[3]) + sympos['totalqty']
            sympos['totalqty'] = trd[1] - sympos['totalqty']
            sympos['qty'] = [[sympos['totalqty'], trd[2]]]
        else:
            sympos['totalqty'] = sympos['totalqty'] - trd[1]
            sz = trd[1]
            while sz > 0:
                if sympos['qty'][0][0] > sz:
                    sympos['qty'][0][0] = sympos['qty'][0][0] - sz
                    sz = 0
                else:
                    sz = sz - sympos['qty'][0][0]
                    sympos['qty'].pop(0)
    return trd[1]

# external flow, HP is holding time in seconds
def update_pos_external(pos, sym, trd, HP):
    sympos = pos[sym]
    trdsz = 0
    sz = trd[1]
    while sz > 0:
        if (trd[2] - sympos['qty'][0][1]).seconds < HP:
            break
        if sympos['qty'][0][0] > sz:
            sympos['qty'][0][0] = sympos[0][0] - sz
            sympos['totalqty'] = sympos['totalqty'] - sz
            trdsz = trdsz + sz
            break
        else:
            sz = sz - sympos['qty'][0][0]
            trdsz = trdsz + sympos['qty'][0][0]
            sympos['totalqty'] = sympos['totalqty'] - sympos['qty'][0][0]
            sympos['qty'].pop(0)
        if len(sympos['qty']) == 0:
            del pos[sym]
            break
    return trdsz

def update_pos_stale(pos, lastpx, ymd, liqday, d_trds):
    net_delta = 0
    abs_delta = 0
    for sym in list(pos):
        sympos = pos[sym]
        clspr = lastpx[sym]
        while True:
            if (d_trds[ymd] - d_trds[sympos['qty'][0][1].strftime('%Y%m%d')]) < liqday:
                break
            else:
                sympos['totalqty'] = sympos['totalqty'] - sympos['qty'][0][0]
                net_delta += sympos['sgn'] * sympos['qty'][0][0] * clspr
                abs_delta += sympos['qty'][0][0] * clspr
                sympos['qty'].pop(0)
            if len(sympos['qty']) == 0:
                del pos[sym]
                break
    return net_delta, abs_delta

def update_pos_hedge(hdg_pos, sgnqty):
    hdg_pos['sgnqty'] = hdg_pos['sgnqty'] + sgnqty

def sim_liq_nxt_day(P=0, HR=10, MD=2, refill=0, acct='DTG_HKI3', LIQDAY=3):
    refill = refill # seconds refill can be 0, 1, 3 seconds
    max_ra_size = 400e3 * 7.7501
    max_rm_size = 100e3 * 7.7501
    params['PerSymMaxDelta'] = params['PerSymMaxDelta'] * MD
    hdg = '2800 HK'
    HP = HR * 60
    st, en = periods[P]
    trds = [x.strftime('%Y%m%d') for x in udt.getTradingDays(st, en)]
    d_trds = dict(zip(trds, range(len(trds))))
    cash = 0.0
    dividends = 0.0
    pos = {}
    hdg_pos = {'sgnqty': 0}
    rows = []
    last_clspr = None
    debug_trades = []
    ra_quote_remaining = max_ra_size
    rm_quote_remianing = max_rm_size
    for dt in udt.getTradingDays(st, en):
        ymd = dt.strftime('%Y%m%d')
        print(ymd)
        if not os.path.exists('D:/data/ndf.{}.ft'.format(ymd)):
            print('warnings: no data on {}'.format(ymd))
            continue
        trdvalue = 0.0
        ntrd = 0
        ndf = feather.read_dataframe('D:/data/ndf.{}.ft'.format(ymd))
        internal_cid = acct.split('_')
        ndf['internal'] = ndf.account.isin(internal_cid)
        universe = pd.read_csv('D:/data/qmm_universe.csv')
        ndf = ndf[ndf.securityid.isin(universe.Symbol)]
        ndf['bbg'] = ndf.bbg.replace('2269 HK', '2963 HK')

        if ndf.qdone_t.min() <= 0:
            print('warnings: qdone_t less than 0 on {}'.formt(ymd))
        if hdg in ndf.bbg.values:
            print('warnings: hedge {} in trading symbol'.format(hdg))

        if len(pos) > 0:
            total_div = adjust_cac(pos, ymd)
            dividends = dividends + total_div
        if np.abs(hdg_pos['sgnqty']) > 0:
            total_div = adjust_cac_hdg(hdg_pos, ymd)
            dividends = dividends + total_div

        last_ra_refill = pd.to_datetime(ymd)
        last_rm_refill = pd.to_datetime(ymd)
        for i in range(ndf.shape[0]):
            rec = ndf.iloc[i, :]
            bbg = rec['bbg']

            max_ra_qdone = int(ra_quote_remaining / rec['lprice'])
            if max_ra_qdone < 100:
                if (rec['stamp'] - last_ra_refill).seconds >= refill:
                    ra_quote_remaining = max_ra_size
                    last_ra_refill = rec['stamp']
                    max_ra_qdone = int(ra_quote_remaining / rec['lprice'])

            max_rm_qdone = int(rm_quote_remaining / rec['lprice'])
            if max_rm_qdone < 100:
                if (rec['stamp'] - last_rm_refill).seconds >= refill:
                    rm_quote_remaining = max_rm_size
                    last_rm_refill = rec['stamp']
                    max_rm_qdone = int(rm_quote_remaining / rec['lprice'])

            if rec['fillside2'] == 'far':
                if rec['internal'] and max_ra_qdone > 0:
                    trdsz = update_pos_internal(pos, bbg, [-rec['sgn'], min(max_ra_qdone, rec['qdone_t']), rec['stamp'], rec['lprice']])
                    if trdsz != 0:
                        ntrd = ntrd + 1
                        cash = cash + rec['sgn'] * trdsz * rec['lprice']
                        trdvalue = trdvalue + trdsz * rec['lprice']
                        hdg_qty = int(np.round(trdsz * rec['lprice'] / rec['hdg_price']))
                        cash = cash - rec['sgn'] * hdg_qty * rec['hdg_price']
                        update_pos_hedge(hdg_pos, rec['sgn'] * hdg_qty)
                        ra_quote_remaining -= trdsz * rec['lprice']
                        debug_trades.append([bbg, -rec['sgn'], trdsz, rec['lprice'], rec['stamp'], 'RA'])
                if (not rec['internal']) and max_rm_qdone > 0:
                    if bbg in pos and pos[bbg]['sgn'] == rec['sgn']:
                        trdsz = update_pos_external(pos, bbg, [-rec['sgn'], min(max_rm_qdone, rec['qdone_t'], rec['stamp'], HP)])
                        if trdsz != 0:
                            ntrd = ntrd + 1
                            trdvalue = trdvalue + trdsz * rec['lprice']
                            cash = cash + rec['sgn'] * trdsz * rec['lprice']
                            hdg_qty = int(np.round(trdsz * rec['lprice'] / rec['hdg_price']))
                            cash = cash - rec['sgn'] * hdg_qty * rec['hdg_price']
                            update_pos_hedge(hdg_pos, rec['sgn'] * hdg_qty)
                            rm_quote_remaining -= trdsz * rec['lprice']
                            debug_trades.append([bbg, -rec['sgn'], trdsz, rec['lprice'], rec['stamp'], 'RM'])

        clspr = ndf.groupby('bbg')['clspr'].first()
        lastpx = clspr.reindex(list(set(list(pos.keys()) + [hdg])))
        if lastpx.isnull().sum() > 0:
            bbgs = lastpx.index.values
            tdf = usm.getsyms(['ric_code', 'bb_composite_code', 'sedol_code'], 'bb_code in ({})'.format(','.join(["'{}'".format(x) for x in bbgs])))
            sedols = tdf.groupby('bb_composite')
            fsyms = ufs.sedol2fsym(sedols)
            fsyms.index = fsyms.sedol.values
            tmp_df = pd.DataFrame(pd.Series(sedols, index=bbgs))
            tmp_df.columns = ['sedol']
            tmp_df['fsym'] = fsyms.fsym.reindex(tmp_df.sedol.values).values
            tmp_df['bbg'] = tmp_df.index.values
            tmp_df.index = tmp_df.fsym.values
            prices = ufs.get_prices(fsyms.fsym.values, st=ymd, en=ymd)
            print(tmp_df.index.value_counts().head())
            prices.index = tmp_df.bbg.reindex(prices.fsym_id.values)
            lastpx[prices.index.values] = prices.p_price.values
        if lastpx.isnull().sum() > 0:
            print("!!!! no close price !!!!")
            print(lastpx[lastpx.isnull()])
            lastpx[lastpx.isnull()] = last_clspr.reindex(lastpx.index[lastpx.isnull()].values).values
        last_clspr = lastpx

        liq_delta, liq_abs_delta = update_pos_stale(pos, lastpx, ymd, LIQDAY, d_trds)
        cash = cash + liq_delta
        hdg_qty = int(np.round(abs(liq_delta) / lastpx[hdg]))
        if hdg_qty > 0:
            hdg_sgn = np.sign(liq_delta)
            cash = cash - hdg_sgn * hdg_qty * lastpx[hdg]
            update_pos_hedge(hdg_pos, hdg_sgn * hdg_qty)

        delta = []
        bookszbyHT = [0.0] * 6
        bbgs = []
        for bbg in pos:
            pos[bbg]['lastpx'] = lastpx[bbg]
            pos[bbg]['delta'] = pos[bbg]['sgn'] * pos[bbg]['totalqty'] * pos[bbg]['lastpx']
            delta.append(pos[bbg]['delta'])
            bbgs.append(bbg)
            for i in range(len(pos[bbg]['qty'])):
                days = d_trds[ymd] - d_trds[pos[bbg]['qty'][i][1].strftime('%Y%m%d')]
                if days > 5:
                    days = 5
                bookszbyHT[days] = bookszbyHT[days] + pos[bbg]['qty'][i][0] * pos[bbg]['lastpx']

        hdg_pos['lastpx'] = lastpx[hdg]
        hdg_pos['delta'] = hdg_pos['sgnqty'] * hdg_pos['lastpx']

        delta = np.array(delta)
        absdelta = np.abs(delta)
        mtm = np.sum(delta)
        pnl = cash + mtm + hdg_pos['delta'] + dividends
        booksz = np.sum(absdelta)
        if True:
            qt = list(np.quantile(np.abs(delta) / booksz, q=[0.5, 0.9, 1.0]))
            symsz = [np.mean(absdelta), np.median(absdelta), np.max(absdelta)]
        else:
            qt = [0.5, 0.9, 1.0]
            symsz = [1, 1, 1]
        row = [ymd, ntrd, pnl, cash, dividends, mtm, hdg_pos['delta'], booksz, trdvalue, liq_abs_delta,
               len(pos)] + symsz + bookszbyHT + qt
        rows.append(row)
    outdf = pd.DataFrame(rows, columns=['ymd', 'ntrd', 'pnl', 'cash', 'dividends', 'mtm', 'hdg_delta', 'booksz',
                                        'trdvalue', 'liq_abs_delta', 'Nsym', 'SymPosMean', 'SymPosMedian', 'SymPosMax']
                                    + ['bksz_{}'.format(i) for i in range(6)]
                                    + ['q0.5', 'q0.9', 'q1'])
    outdf.to_csv(('Y:/sim_result.csv'))

def analyze_sim_results():
    P = 0
    MDs = [2]
    HRs = [10]
    LIQDAYs = [1, 3, 5]
    grossbooksz = []
    netbooksz = []
    trdvalues = []
    liqvalues = []
    pnls = []
    remains = []
    refills = [0, 1, 3]
    acct = 'DTG_HKI3'
    HR = 10
    refill = 1
    for MD in MDs:
        for HR in HRs:
            for LIQDAY in LIQDAYs:
                df = pd.read_csv('sim_MD={}_P={}_HR={}_Refill={}_Acct={}_LIQDAY={}.csv'.format(MD, P, HR, refill, acct, LIQDAY), index_col=0)
                df.index = pd.to_datetime(df.ymd.values.astype(str))
                tdf = pd.concat([df.trdvalue, df.bksz_0, df.bksz_1.shift(-1), df.bksz_2.shift(-2), df.bksz_3.shift(-3), df.bksz_4.shift(-4), df.bksz_5.shift(-5)], axis=1)
                ss = tdf[~tdf.isnull().any(axis=1)].sum()
                remains.append(list(ss.values[1:] / ss.values[0]))
                netbooksz.append(df.mtm)
                grossbooksz.append(df.booksz)
                trdvalues.append(df.trdvalue.cumsum())
                liqvalues.append(df.liq_abs_delta.cumsum())
                pnls.append(df.pnl)
    colnms = ['MD_{}_HR_{}_LIQDAY_{}'.format(x, y, z) for (x, y, z) in list(itertools.product(MDs, HRs, LIQDAYs))]
    df_remain = pd.DataFrame(remains).T
    df_remain.columns = ['{}'.format(x) for x in colnms]
    df_remain.iloc[0:5, :].plot(title='position remaining')

    df_pnl = pd.concat(pnls, axis=1)
    df_pnl.columns = ['{}'.format(x) for x in colnms]
    df_pnl = df_pnl / 7.8
    df_pnl.plot(title='pnl')

    df_pnl = pd.concat(grossbooksz, axis=1)
    df_pnl.columns = ['{}'.format(x) for x in colnms]
    df_pnl = df_pnl / 7.8
    df_pnl.plot(title='Gross book size (excluding hedges')

    df_pnl = pd.concat(netbooksz, axis=1)
    df_pnl.columns = ['{}'.format(x) for x in colnms]
    df_pnl = df_pnl / 7.8
    df_pnl.plot(title='Net book size (excluding hedge')

    df_pnl = pd.concat(trdvalues, axis=1)
    df_pnl.columns = ['{}'.format(x) for x in colnms]
    df_pnl = df_pnl / 7.8
    df_pnl.plot(title='Cumulative trade values')

    df_pnl = pd.concat(liqvalues, axis=1)
    df_pnl.columns = ['{}'.format(x) for x in colnms]
    df_pnl = df_pnl / 7.8
    df_pnl.plot(title='Cumulative Liquidation Values')

if __name__ == '__main__':
    sim_liq_nxt_day(P=0, HR=10, MD=2, refill=1, acct='DTG', LIQDAY=5)
    #pass




